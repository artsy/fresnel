{"version":3,"sources":["../src/Utils.ts"],"names":["propKey","breakpointProps","Object","keys","intersection","a1","a2","filter","element","indexOf","createRuleSet","className","query","createClassName","components","reduce","acc","breakpoint","Array","isArray","join","castBreakpointsToIntegers","breakpoints","previous","current","currentIndex","Math","round","Number","memoize","func","results","args","argsKey","JSON","stringify","useIsFirstRender","isFirst"],"mappings":";;;;;;;;;;;;;AAEA;;;;;;;;;;;;;;;;;;AAEA;AACA;AACA;AACO,SAASA,OAAT,CAAiBC,eAAjB,EAAwD;AAC7D,SAAOC,MAAM,CAACC,IAAP,CAAYF,eAAZ,EAA6B,CAA7B,CAAP;AACD;AAED;AACA;AACA;;;AACO,SAASG,YAAT,CACLC,EADK,EAELC,EAFK,EAGE;AACP,SAAOA,EAAE,GAAGD,EAAE,CAACE,MAAH,CAAU,UAAAC,OAAO;AAAA,WAAIF,EAAE,CAACG,OAAH,CAAWD,OAAX,KAAuB,CAA3B;AAAA,GAAjB,CAAH,sBAAwDH,EAAxD,CAAT;AACD;AAED;AACA;AACA;AACA;;;AACO,SAASK,aAAT,CAAuBC,SAAvB,EAA0CC,KAA1C,EAAyD;AAC9D,0BAAiBA,KAAjB,eAA2BD,SAA3B;AACD;AAED;AACA;AACA;;;AACO,SAASE,eAAT,GAEL;AAAA,oCADGC,UACH;AADGA,IAAAA,UACH;AAAA;;AACA,SAAO,CACL,SADK,4BAEFA,UAAU,CAACC,MAAX,CACD,UAACC,GAAD,EAAgBC,UAAhB;AAAA,WACEC,KAAK,CAACC,OAAN,CAAcF,UAAd,uBACQD,GADR,4BACgBC,UADhB,wBAEQD,GAFR,UAEaC,UAFb,EADF;AAAA,GADC,EAKD,EALC,CAFE,GASLG,IATK,CASA,GATA,CAAP;AAUD;AAED;AACA;AACA;;;AACO,SAASC,yBAAT,CAAmCC,WAAnC,EAEuB;AAC5B,MAAMnB,IAAI,GAAGD,MAAM,CAACC,IAAP,CAAYmB,WAAZ,CAAb;AAEA,SAAOnB,IAAI,CAACY,MAAL,CACL,UAACQ,QAAD,EAAWC,OAAX,EAAoBC,YAApB;AAAA,6BACKF,QADL,sBAEGpB,IAAI,CAACsB,YAAD,CAFP,EAEwBC,IAAI,CAACC,KAAL,CAAWC,MAAM,CAACN,WAAW,CAACE,OAAD,CAAZ,CAAjB,CAFxB;AAAA,GADK,EAKL,EALK,CAAP;AAOD;AAED;AACA;AACA;;;AACO,SAASK,OAAT,CAAqDC,IAArD,EAA8D;AACnE,MAAMC,OAAO,GAAG,EAAhB;AACA,SAAO,YAAa;AAAA,uCAATC,IAAS;AAATA,MAAAA,IAAS;AAAA;;AAClB,QAAMC,OAAO,GAAGC,IAAI,CAACC,SAAL,CAAeH,IAAf,CAAhB;;AACA,QAAI,CAACD,OAAO,CAACE,OAAD,CAAZ,EAAuB;AACrBF,MAAAA,OAAO,CAACE,OAAD,CAAP,GAAmBH,IAAI,MAAJ,SAAQE,IAAR,CAAnB;AACD;;AACD,WAAOD,OAAO,CAACE,OAAD,CAAd;AACD,GAND;AAOD;AAED;AACA;AACA;;;AACO,SAASG,gBAAT,GAAqC;AAC1C,MAAMC,OAAO,GAAG,mBAAO,IAAP,CAAhB;;AAEA,MAAIA,OAAO,CAACb,OAAZ,EAAqB;AACnBa,IAAAA,OAAO,CAACb,OAAR,GAAkB,KAAlB;AACA,WAAO,IAAP;AACD,GAHD,MAGO;AACL,WAAO,KAAP;AACD;AACF","sourcesContent":["import { MediaBreakpointProps } from \"./Media\"\nimport { BreakpointConstraintKey } from \"./Breakpoints\"\nimport { useRef } from \"react\"\n\n/**\n * Extracts the single breakpoint prop from the props object.\n */\nexport function propKey(breakpointProps: MediaBreakpointProps) {\n  return Object.keys(breakpointProps)[0] as BreakpointConstraintKey\n}\n\n/**\n * Returns the intersection of two arrays.\n */\nexport function intersection(\n  a1: ReadonlyArray<any>,\n  a2?: ReadonlyArray<any>\n): any[] {\n  return a2 ? a1.filter(element => a2.indexOf(element) >= 0) : [...a1]\n}\n\n/**\n * Generate a style rule for a given class name that will hide the element\n * when the given query matches.\n */\nexport function createRuleSet(className: string, query: string) {\n  return `@media ${query}{.${className}{display:none!important;}}`\n}\n\n/**\n * Given a list of strings, or string tuples, generates a class name.\n */\nexport function createClassName(\n  ...components: Array<string | [string, string]>\n) {\n  return [\n    \"fresnel\",\n    ...components.reduce(\n      (acc: string[], breakpoint) =>\n        Array.isArray(breakpoint)\n          ? [...acc, ...breakpoint]\n          : [...acc, breakpoint],\n      []\n    ),\n  ].join(\"-\")\n}\n\n/**\n * Returns an object with every values casted to integers.\n */\nexport function castBreakpointsToIntegers(breakpoints: {\n  [key: string]: number | string\n}): { [key: string]: number } {\n  const keys = Object.keys(breakpoints)\n\n  return keys.reduce(\n    (previous, current, currentIndex) => ({\n      ...previous,\n      [keys[currentIndex]]: Math.round(Number(breakpoints[current])),\n    }),\n    {}\n  )\n}\n\n/**\n * Use this function to memoize any function\n */\nexport function memoize<F extends (...args: any[]) => void>(func: F) {\n  const results = {}\n  return (...args) => {\n    const argsKey = JSON.stringify(args)\n    if (!results[argsKey]) {\n      results[argsKey] = func(...args)\n    }\n    return results[argsKey]\n  }\n}\n\n/**\n * Hook to determine if the current render is the first render.\n */\nexport function useIsFirstRender(): boolean {\n  const isFirst = useRef(true)\n\n  if (isFirst.current) {\n    isFirst.current = false\n    return true\n  } else {\n    return false\n  }\n}\n"],"file":"Utils.js"}